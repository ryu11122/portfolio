const pixelContainer2 = document.getElementById('pixel-container2');
const stackHeights2 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer3 = document.getElementById('pixel-container3');
const stackHeights3 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer4 = document.getElementById('pixel-container4');
const stackHeights4 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer5 = document.getElementById('pixel-container5');
const stackHeights5 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer6 = document.getElementById('pixel-container6');
const stackHeights6 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer7 = document.getElementById('pixel-container7');
const stackHeights7 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer8 = document.getElementById('pixel-container8');
const stackHeights8 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer9 = document.getElementById('pixel-container9');
const stackHeights9 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer10 = document.getElementById('pixel-container10');
const stackHeights10 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer11 = document.getElementById('pixel-container11');
const stackHeights11 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer12 = document.getElementById('pixel-container12');
const stackHeights12 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer13 = document.getElementById('pixel-container13');
const stackHeights13 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer14 = document.getElementById('pixel-container14');
const stackHeights14 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer15 = document.getElementById('pixel-container15');
const stackHeights15 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer16 = document.getElementById('pixel-container16');
const stackHeights16 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer17 = document.getElementById('pixel-container17');
const stackHeights17 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer18 = document.getElementById('pixel-container18');
const stackHeights18 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer19 = document.getElementById('pixel-container19');
const stackHeights19 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer20 = document.getElementById('pixel-container20');
const stackHeights20 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer21 = document.getElementById('pixel-container21');
const stackHeights21 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer22 = document.getElementById('pixel-container22');
const stackHeights22 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer23 = document.getElementById('pixel-container23');
const stackHeights23 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer24 = document.getElementById('pixel-container24');
const stackHeights24 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer25 = document.getElementById('pixel-container25');
const stackHeights25 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer26 = document.getElementById('pixel-container26');
const stackHeights26 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer27 = document.getElementById('pixel-container27');
const stackHeights27 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer28 = document.getElementById('pixel-container28');
const stackHeights28 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer29 = document.getElementById('pixel-container29');
const stackHeights29 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer30 = document.getElementById('pixel-container30');
const stackHeights30 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer31 = document.getElementById('pixel-container31');
const stackHeights31 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer32 = document.getElementById('pixel-container32');
const stackHeights32 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer33 = document.getElementById('pixel-container33');
const stackHeights33 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer34 = document.getElementById('pixel-container34');
const stackHeights34 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer35 = document.getElementById('pixel-container35');
const stackHeights35 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer36 = document.getElementById('pixel-container36');
const stackHeights36 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer37 = document.getElementById('pixel-container37');
const stackHeights37 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer38 = document.getElementById('pixel-container38');
const stackHeights38 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer39 = document.getElementById('pixel-container39');
const stackHeights39 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer40 = document.getElementById('pixel-container40');
const stackHeights40 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer41 = document.getElementById('pixel-container41');
const stackHeights41 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer42 = document.getElementById('pixel-container42');
const stackHeights42 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer43 = document.getElementById('pixel-container43');
const stackHeights43 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer44 = document.getElementById('pixel-container44');
const stackHeights44 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer45 = document.getElementById('pixel-container45');
const stackHeights45 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer46 = document.getElementById('pixel-container46');
const stackHeights46 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer47 = document.getElementById('pixel-container47');
const stackHeights47 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer48 = document.getElementById('pixel-container48');
const stackHeights48 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer49 = document.getElementById('pixel-container49');
const stackHeights49 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer50 = document.getElementById('pixel-container50');
const stackHeights50 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer51 = document.getElementById('pixel-container51');
const stackHeights51 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer52 = document.getElementById('pixel-container52');
const stackHeights52 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer53 = document.getElementById('pixel-container53');
const stackHeights53 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer54 = document.getElementById('pixel-container54');
const stackHeights54 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer55 = document.getElementById('pixel-container55');
const stackHeights55 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer56 = document.getElementById('pixel-container56');
const stackHeights56 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer57 = document.getElementById('pixel-container57');
const stackHeights57 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer58 = document.getElementById('pixel-container58');
const stackHeights58 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer59 = document.getElementById('pixel-container59');
const stackHeights59 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer60 = document.getElementById('pixel-container60');
const stackHeights60 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer61 = document.getElementById('pixel-container61');
const stackHeights61 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer62 = document.getElementById('pixel-container62');
const stackHeights62 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer63 = document.getElementById('pixel-container63');
const stackHeights63 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer64 = document.getElementById('pixel-container64');
const stackHeights64 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer65 = document.getElementById('pixel-container65');
const stackHeights65 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer66 = document.getElementById('pixel-container66');
const stackHeights66 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer67 = document.getElementById('pixel-container67');
const stackHeights67 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer68 = document.getElementById('pixel-container68');
const stackHeights68 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer69 = document.getElementById('pixel-container69');
const stackHeights69 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer70 = document.getElementById('pixel-container70');
const stackHeights70 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer71 = document.getElementById('pixel-container71');
const stackHeights71 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer72 = document.getElementById('pixel-container72');
const stackHeights72 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer73 = document.getElementById('pixel-container73');
const stackHeights73 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer74 = document.getElementById('pixel-container74');
const stackHeights74 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer75 = document.getElementById('pixel-container75');
const stackHeights75 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer76 = document.getElementById('pixel-container76');
const stackHeights76 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer77 = document.getElementById('pixel-container77');
const stackHeights77 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer78 = document.getElementById('pixel-container78');
const stackHeights78 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer79 = document.getElementById('pixel-container79');
const stackHeights79 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer80 = document.getElementById('pixel-container80');
const stackHeights80 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer81 = document.getElementById('pixel-container81');
const stackHeights81 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer82 = document.getElementById('pixel-container82');
const stackHeights82 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer83 = document.getElementById('pixel-container83');
const stackHeights83 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer84 = document.getElementById('pixel-container84');
const stackHeights84 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer85 = document.getElementById('pixel-container85');
const stackHeights85 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer86 = document.getElementById('pixel-container86');
const stackHeights86 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer87 = document.getElementById('pixel-container87');
const stackHeights87 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer88 = document.getElementById('pixel-container88');
const stackHeights88 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer89 = document.getElementById('pixel-container89');
const stackHeights89 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer90 = document.getElementById('pixel-container90');
const stackHeights90 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체
const pixelContainer91 = document.getElementById('pixel-container91');
const stackHeights91 = {};  // 각 x 위치별로 쌓이는 높이를 저장하는 객체






function createPixel2() {
    const pixel2 = document.createElement('div');
    pixel2.classList.add('pixel2');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition2 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel2.style.left = `${leftPosition2}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor2 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel2.style.backgroundColor = randomColor2;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights2[leftPosition2]) {
        stackHeights2[leftPosition2] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration2 = Math.random() * 2;
    pixel2.style.animationDuration = `${duration2}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition2 < 3) {
        pixelContainer2.appendChild(pixel2);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel2.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel2.style.bottom = `${stackHeights2[leftPosition2]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights2[leftPosition2] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights2[leftPosition2] > 61) {
                pixelContainer2.removeChild(pixel2)
            } else if (leftPosition2 > 3) {
                pixelContainer2.removeChild(pixel2)
            }

        }, duration2 * 1000);
    }
}


// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel2, 10);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel3() {
    const pixel3 = document.createElement('div');
    pixel3.classList.add('pixel3');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition3 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel3.style.left = `${leftPosition3}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor3 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel3.style.backgroundColor = randomColor3;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights3[leftPosition3]) {
        stackHeights3[leftPosition3] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration3 = Math.random() * 2;
    pixel3.style.animationDuration = `${duration3}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition3 < 3) {
        pixelContainer3.appendChild(pixel3);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel3.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel3.style.bottom = `${stackHeights3[leftPosition3]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights3[leftPosition3] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights3[leftPosition3] > 61) {
                pixelContainer3.removeChild(pixel3)
            } else if (leftPosition3 > 3) {
                pixelContainer3.removeChild(pixel3)
            }

        }, duration3 * 1000);
    }
}



// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel3, 10);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel4() {
    const pixel4 = document.createElement('div');
    pixel4.classList.add('pixel4');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition4 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel4.style.left = `${leftPosition4}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor4 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel4.style.backgroundColor = randomColor4;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights4[leftPosition4]) {
        stackHeights4[leftPosition4] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration4 = Math.random() * 2;
    pixel4.style.animationDuration = `${duration4}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition4 < 3) {
        pixelContainer4.appendChild(pixel4);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel4.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel4.style.bottom = `${stackHeights4[leftPosition4]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights4[leftPosition4] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights4[leftPosition4] > 61) {
                pixelContainer4.removeChild(pixel4)
            } else if (leftPosition4 > 3) {
                pixelContainer4.removeChild(pixel4)
            }

        }, duration4 * 1000);
    }
}



// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel4, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임




function createPixel5() {
    const pixel5 = document.createElement('div');
    pixel5.classList.add('pixel5');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition5 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel5.style.left = `${leftPosition5}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor5 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel5.style.backgroundColor = randomColor5;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights5[leftPosition5]) {
        stackHeights5[leftPosition5] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration5 = Math.random() * 2;
    pixel5.style.animationDuration = `${duration5}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition5 < 3) {
        pixelContainer5.appendChild(pixel5);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel5.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel5.style.bottom = `${stackHeights5[leftPosition5]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights5[leftPosition5] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights5[leftPosition5] > 61) {
                pixelContainer5.removeChild(pixel5)
            } else if (leftPosition5 > 3) {
                pixelContainer5.removeChild(pixel5)
            }

        }, duration5 * 1000);
    }
}


// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel5, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel6() {
    const pixel6 = document.createElement('div');
    pixel6.classList.add('pixel6');
    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition6 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);

    pixel6.style.left = `${leftPosition6}vw`;


    // 픽셀의 색상을 랜덤으로 지정
    const randomColor6 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel6.style.backgroundColor = randomColor6;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights6[leftPosition6]) {
        stackHeights6[leftPosition6] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration6 = Math.random() * 2;
    pixel6.style.animationDuration = `${duration6}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition6 < 3) {
        pixelContainer6.appendChild(pixel6);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel6.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel6.style.bottom = `${stackHeights6[leftPosition6]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights6[leftPosition6] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights6[leftPosition6] > 61) {
                pixelContainer6.removeChild(pixel6)
            } else if (leftPosition6 > 3) {
                pixelContainer6.removeChild(pixel6)
            }

        }, duration6 * 1000);
    }
}


// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel6, 10);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel7() {
    const pixel7 = document.createElement('div');
    pixel7.classList.add('pixel7');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition7 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel7.style.left = `${leftPosition7}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor7 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel7.style.backgroundColor = randomColor7;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights7[leftPosition7]) {
        stackHeights7[leftPosition7] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration7 = Math.random() * 2;
    pixel7.style.animationDuration = `${duration7}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition7 < 3) {
        pixelContainer7.appendChild(pixel7);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel7.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel7.style.bottom = `${stackHeights7[leftPosition7]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights7[leftPosition7] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights7[leftPosition7] > 61) {
                pixelContainer7.removeChild(pixel7)
            } else if (leftPosition7 > 3) {
                pixelContainer7.removeChild(pixel7)
            }

        }, duration7 * 1000);
    }
}


// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel7, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임





function createPixel8() {
    const pixel8 = document.createElement('div');
    pixel8.classList.add('pixel8');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition8 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel8.style.left = `${leftPosition8}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor8 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel8.style.backgroundColor = randomColor8;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights8[leftPosition8]) {
        stackHeights8[leftPosition8] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration8 = Math.random() * 2;
    pixel8.style.animationDuration = `${duration8}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition8 < 3) {
        pixelContainer8.appendChild(pixel8);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel8.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel8.style.bottom = `${stackHeights8[leftPosition8]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights8[leftPosition8] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights8[leftPosition8] > 61) {
                pixelContainer8.removeChild(pixel8)
            } else if (leftPosition8 > 3) {
                pixelContainer8.removeChild(pixel8)
            }

        }, duration8 * 1000);
    }
}


// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel8, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임




function createPixel9() {
    const pixel9 = document.createElement('div');
    pixel9.classList.add('pixel9');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition9 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel9.style.left = `${leftPosition9}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor9 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel9.style.backgroundColor = randomColor9;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights9[leftPosition9]) {
        stackHeights9[leftPosition9] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration9 = Math.random() * 2;
    pixel9.style.animationDuration = `${duration9}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition9 < 3) {
        pixelContainer9.appendChild(pixel9);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel9.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel9.style.bottom = `${stackHeights9[leftPosition9]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights9[leftPosition9] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights9[leftPosition9] > 61) {
                pixelContainer9.removeChild(pixel9)
            } else if (leftPosition9 > 3) {
                pixelContainer9.removeChild(pixel9)
            }

        }, duration9 * 1000);
    }
}


// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel9, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel10() {
    const pixel10 = document.createElement('div');
    pixel10.classList.add('pixel10');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition10 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel10.style.left = `${leftPosition10}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor10 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel10.style.backgroundColor = randomColor10;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights10[leftPosition10]) {
        stackHeights10[leftPosition10] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration10 = Math.random() * 2;
    pixel10.style.animationDuration = `${duration10}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition10 < 3) {
        pixelContainer10.appendChild(pixel10);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel10.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel10.style.bottom = `${stackHeights10[leftPosition10]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights10[leftPosition10] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights10[leftPosition10] > 61) {
                pixelContainer10.removeChild(pixel10)
            } else if (leftPosition10 > 3) {
                pixelContainer10.removeChild(pixel10)
            }

        }, duration10 * 1000);
    }
}


// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel10, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임




function createPixel11() {
    const pixel11 = document.createElement('div');
    pixel11.classList.add('pixel11');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition11 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel11.style.left = `${leftPosition11}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor11 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel11.style.backgroundColor = randomColor11;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights11[leftPosition11]) {
        stackHeights11[leftPosition11] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration11 = Math.random() * 2;
    pixel11.style.animationDuration = `${duration11}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition11 < 3) {
        pixelContainer11.appendChild(pixel11);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel11.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel11.style.bottom = `${stackHeights11[leftPosition11]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights11[leftPosition11] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights11[leftPosition11] > 61) {
                pixelContainer11.removeChild(pixel11)
            } else if (leftPosition11 > 3) {
                pixelContainer11.removeChild(pixel11)
            }

        }, duration11 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel11, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임


function createPixel12() {
    const pixel12 = document.createElement('div');
    pixel12.classList.add('pixel12');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition12 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel12.style.left = `${leftPosition12}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor12 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel12.style.backgroundColor = randomColor12;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights12[leftPosition12]) {
        stackHeights12[leftPosition12] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration12 = Math.random() * 2;
    pixel12.style.animationDuration = `${duration12}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition12 < 3) {
        pixelContainer12.appendChild(pixel12);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel12.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel12.style.bottom = `${stackHeights12[leftPosition12]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights12[leftPosition12] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights12[leftPosition12] > 61) {
                pixelContainer12.removeChild(pixel12)
            } else if (leftPosition12 > 3) {
                pixelContainer12.removeChild(pixel12)
            }

        }, duration12 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel12, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel13() {
    const pixel13 = document.createElement('div');
    pixel13.classList.add('pixel13');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition13 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel13.style.left = `${leftPosition13}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor13 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel13.style.backgroundColor = randomColor13;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights13[leftPosition13]) {
        stackHeights13[leftPosition13] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration13 = Math.random() * 2;
    pixel13.style.animationDuration = `${duration13}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition13 < 3) {
        pixelContainer13.appendChild(pixel13);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel13.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel13.style.bottom = `${stackHeights13[leftPosition13]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights13[leftPosition13] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights13[leftPosition13] > 61) {
                pixelContainer13.removeChild(pixel13)
            } else if (leftPosition13 > 3) {
                pixelContainer13.removeChild(pixel13)
            }

        }, duration13 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel13, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel14() {
    const pixel14 = document.createElement('div');
    pixel14.classList.add('pixel14');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition14 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel14.style.left = `${leftPosition14}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor14 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel14.style.backgroundColor = randomColor14;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights14[leftPosition14]) {
        stackHeights14[leftPosition14] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration14 = Math.random() * 2;
    pixel14.style.animationDuration = `${duration14}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition14 < 3) {
        pixelContainer14.appendChild(pixel14);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel14.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel14.style.bottom = `${stackHeights14[leftPosition14]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights14[leftPosition14] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights14[leftPosition14] > 61) {
                pixelContainer14.removeChild(pixel14)
            } else if (leftPosition14 > 3) {
                pixelContainer14.removeChild(pixel14)
            }

        }, duration14 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel14, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel15() {
    const pixel15 = document.createElement('div');
    pixel15.classList.add('pixel15');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition15 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel15.style.left = `${leftPosition15}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor15 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel15.style.backgroundColor = randomColor15;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights15[leftPosition15]) {
        stackHeights15[leftPosition15] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration15 = Math.random() * 2;
    pixel15.style.animationDuration = `${duration15}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition15 < 3) {
        pixelContainer15.appendChild(pixel15);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel15.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel15.style.bottom = `${stackHeights15[leftPosition15]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights15[leftPosition15] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights15[leftPosition15] > 61) {
                pixelContainer15.removeChild(pixel15)
            } else if (leftPosition15 > 3) {
                pixelContainer15.removeChild(pixel15)
            }

        }, duration15 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel15, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel16() {
    const pixel16 = document.createElement('div');
    pixel16.classList.add('pixel16');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition16 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel16.style.left = `${leftPosition16}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor16 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel16.style.backgroundColor = randomColor16;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights16[leftPosition16]) {
        stackHeights16[leftPosition16] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration16 = Math.random() * 2;
    pixel16.style.animationDuration = `${duration16}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition16 < 3) {
        pixelContainer16.appendChild(pixel16);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel16.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel16.style.bottom = `${stackHeights16[leftPosition16]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights16[leftPosition16] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights16[leftPosition16] > 61) {
                pixelContainer16.removeChild(pixel16)
            } else if (leftPosition16 > 3) {
                pixelContainer16.removeChild(pixel16)
            }

        }, duration16 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel16, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel17() {
    const pixel17 = document.createElement('div');
    pixel17.classList.add('pixel17');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition17 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel17.style.left = `${leftPosition17}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor17 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel17.style.backgroundColor = randomColor17;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights17[leftPosition17]) {
        stackHeights17[leftPosition17] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration17 = Math.random() * 2;
    pixel17.style.animationDuration = `${duration17}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition17 < 3) {
        pixelContainer17.appendChild(pixel17);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel17.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel17.style.bottom = `${stackHeights17[leftPosition17]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights17[leftPosition17] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights17[leftPosition17] > 61) {
                pixelContainer17.removeChild(pixel17)
            } else if (leftPosition17 > 3) {
                pixelContainer17.removeChild(pixel17)
            }

        }, duration17 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel17, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel18() {
    const pixel18 = document.createElement('div');
    pixel18.classList.add('pixel18');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition18 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel18.style.left = `${leftPosition18}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor18 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel18.style.backgroundColor = randomColor18;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights18[leftPosition18]) {
        stackHeights18[leftPosition18] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration18 = Math.random() * 2;
    pixel18.style.animationDuration = `${duration18}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition18 < 3) {
        pixelContainer18.appendChild(pixel18);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel18.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel18.style.bottom = `${stackHeights18[leftPosition18]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights18[leftPosition18] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights18[leftPosition18] > 61) {
                pixelContainer18.removeChild(pixel18)
            } else if (leftPosition18 > 3) {
                pixelContainer18.removeChild(pixel18)
            }

        }, duration18 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel18, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel19() {
    const pixel19 = document.createElement('div');
    pixel19.classList.add('pixel19');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition19 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel19.style.left = `${leftPosition19}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor19 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel19.style.backgroundColor = randomColor19;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights19[leftPosition19]) {
        stackHeights19[leftPosition19] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration19 = Math.random() * 2;
    pixel19.style.animationDuration = `${duration19}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition19 < 3) {
        pixelContainer19.appendChild(pixel19);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel19.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel19.style.bottom = `${stackHeights19[leftPosition19]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights19[leftPosition19] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights19[leftPosition19] > 61) {
                pixelContainer19.removeChild(pixel19)
            } else if (leftPosition19 > 3) {
                pixelContainer19.removeChild(pixel19)
            }

        }, duration19 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel19, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel20() {
    const pixel20 = document.createElement('div');
    pixel20.classList.add('pixel20');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition20 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel20.style.left = `${leftPosition20}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor20 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel20.style.backgroundColor = randomColor20;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights20[leftPosition20]) {
        stackHeights20[leftPosition20] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration20 = Math.random() * 2;
    pixel20.style.animationDuration = `${duration20}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition20 < 3) {
        pixelContainer20.appendChild(pixel20);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel20.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel20.style.bottom = `${stackHeights20[leftPosition20]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights20[leftPosition20] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights20[leftPosition20] > 61) {
                pixelContainer20.removeChild(pixel20)
            } else if (leftPosition20 > 3) {
                pixelContainer20.removeChild(pixel20)
            }

        }, duration20 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel20, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel21() {
    const pixel21 = document.createElement('div');
    pixel21.classList.add('pixel21');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition21 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel21.style.left = `${leftPosition21}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor21 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel21.style.backgroundColor = randomColor21;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights21[leftPosition21]) {
        stackHeights21[leftPosition21] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration21 = Math.random() * 2;
    pixel21.style.animationDuration = `${duration21}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition21 < 3) {
        pixelContainer21.appendChild(pixel21);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel21.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel21.style.bottom = `${stackHeights21[leftPosition21]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights21[leftPosition21] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights21[leftPosition21] > 61) {
                pixelContainer21.removeChild(pixel21)
            } else if (leftPosition21 > 3) {
                pixelContainer21.removeChild(pixel21)
            }

        }, duration21 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel21, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel22() {
    const pixel22 = document.createElement('div');
    pixel22.classList.add('pixel22');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition22 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel22.style.left = `${leftPosition22}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor22 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel22.style.backgroundColor = randomColor22;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights22[leftPosition22]) {
        stackHeights22[leftPosition22] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration22 = Math.random() * 2;
    pixel22.style.animationDuration = `${duration22}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition22 < 3) {
        pixelContainer22.appendChild(pixel22);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel22.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel22.style.bottom = `${stackHeights22[leftPosition22]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights22[leftPosition22] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights22[leftPosition22] > 61) {
                pixelContainer22.removeChild(pixel22)
            } else if (leftPosition22 > 3) {
                pixelContainer22.removeChild(pixel22)
            }

        }, duration22 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel22, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임


function createPixel23() {
    const pixel23 = document.createElement('div');
    pixel23.classList.add('pixel23');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition23 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel23.style.left = `${leftPosition23}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor23 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel23.style.backgroundColor = randomColor23;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights23[leftPosition23]) {
        stackHeights23[leftPosition23] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration23 = Math.random() * 2;
    pixel23.style.animationDuration = `${duration23}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition23 < 3) {
        pixelContainer23.appendChild(pixel23);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel23.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel23.style.bottom = `${stackHeights23[leftPosition23]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights23[leftPosition23] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights23[leftPosition23] > 61) {
                pixelContainer23.removeChild(pixel23)
            } else if (leftPosition23 > 3) {
                pixelContainer23.removeChild(pixel23)
            }

        }, duration23 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel23, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임






function createPixel24() {
    const pixel24 = document.createElement('div');
    pixel24.classList.add('pixel24');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition24 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel24.style.left = `${leftPosition24}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor24 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel24.style.backgroundColor = randomColor24;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights24[leftPosition24]) {
        stackHeights24[leftPosition24] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration24 = Math.random() * 2;
    pixel24.style.animationDuration = `${duration24}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition24 < 3) {
        pixelContainer24.appendChild(pixel24);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel24.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel24.style.bottom = `${stackHeights24[leftPosition24]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights24[leftPosition24] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights24[leftPosition24] > 61) {
                pixelContainer24.removeChild(pixel24)
            } else if (leftPosition24 > 3) {
                pixelContainer24.removeChild(pixel24)
            }

        }, duration24 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel24, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임




function createPixel25() {
    const pixel25 = document.createElement('div');
    pixel25.classList.add('pixel25');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition25 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel25.style.left = `${leftPosition25}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor25 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel25.style.backgroundColor = randomColor25;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights25[leftPosition25]) {
        stackHeights25[leftPosition25] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration25 = Math.random() * 2;
    pixel25.style.animationDuration = `${duration25}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition25 < 3) {
        pixelContainer25.appendChild(pixel25);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel25.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel25.style.bottom = `${stackHeights25[leftPosition25]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights25[leftPosition25] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights25[leftPosition25] > 61) {
                pixelContainer25.removeChild(pixel25)
            } else if (leftPosition25 > 3) {
                pixelContainer25.removeChild(pixel25)
            }

        }, duration25 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel25, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel26() {
    const pixel26 = document.createElement('div');
    pixel26.classList.add('pixel26');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition26 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel26.style.left = `${leftPosition26}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor26 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel26.style.backgroundColor = randomColor26;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights26[leftPosition26]) {
        stackHeights26[leftPosition26] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration26 = Math.random() * 2;
    pixel26.style.animationDuration = `${duration26}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition26 < 3) {
        pixelContainer26.appendChild(pixel26);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel26.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel26.style.bottom = `${stackHeights26[leftPosition26]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights26[leftPosition26] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights26[leftPosition26] > 61) {
                pixelContainer26.removeChild(pixel26)
            } else if (leftPosition26 > 3) {
                pixelContainer26.removeChild(pixel26)
            }

        }, duration26 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel26, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel27() {
    const pixel27 = document.createElement('div');
    pixel27.classList.add('pixel27');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition27 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel27.style.left = `${leftPosition27}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor27 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel27.style.backgroundColor = randomColor27;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights27[leftPosition27]) {
        stackHeights27[leftPosition27] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration27 = Math.random() * 2;
    pixel27.style.animationDuration = `${duration27}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition27 < 3) {
        pixelContainer27.appendChild(pixel27);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel27.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel27.style.bottom = `${stackHeights27[leftPosition27]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights27[leftPosition27] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights27[leftPosition27] > 61) {
                pixelContainer27.removeChild(pixel27)
            } else if (leftPosition27 > 3) {
                pixelContainer27.removeChild(pixel27)
            }

        }, duration27 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel27, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel28() {
    const pixel28 = document.createElement('div');
    pixel28.classList.add('pixel28');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition28 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel28.style.left = `${leftPosition28}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor28 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel28.style.backgroundColor = randomColor28;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights28[leftPosition28]) {
        stackHeights28[leftPosition28] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration28 = Math.random() * 2;
    pixel28.style.animationDuration = `${duration28}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition28 < 3) {
        pixelContainer28.appendChild(pixel28);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel28.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel28.style.bottom = `${stackHeights28[leftPosition28]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights28[leftPosition28] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights28[leftPosition28] > 61) {
                pixelContainer28.removeChild(pixel28)
            } else if (leftPosition28 > 3) {
                pixelContainer28.removeChild(pixel28)
            }

        }, duration28 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel28, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel29() {
    const pixel29 = document.createElement('div');
    pixel29.classList.add('pixel29');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition29 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel29.style.left = `${leftPosition29}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor29 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel29.style.backgroundColor = randomColor29;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights29[leftPosition29]) {
        stackHeights29[leftPosition29] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration29 = Math.random() * 2;
    pixel29.style.animationDuration = `${duration29}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition29 < 3) {
        pixelContainer29.appendChild(pixel29);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel29.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel29.style.bottom = `${stackHeights29[leftPosition29]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights29[leftPosition29] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights29[leftPosition29] > 61) {
                pixelContainer29.removeChild(pixel29)
            } else if (leftPosition29 > 3) {
                pixelContainer29.removeChild(pixel29)
            }

        }, duration29 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel29, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel30() {
    const pixel30 = document.createElement('div');
    pixel30.classList.add('pixel30');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition30 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel30.style.left = `${leftPosition30}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor30 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel30.style.backgroundColor = randomColor30;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights30[leftPosition30]) {
        stackHeights30[leftPosition30] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration30 = Math.random() * 2;
    pixel30.style.animationDuration = `${duration30}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition30 < 3) {
        pixelContainer30.appendChild(pixel30);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel30.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel30.style.bottom = `${stackHeights30[leftPosition30]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights30[leftPosition30] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights30[leftPosition30] > 61) {
                pixelContainer30.removeChild(pixel30)
            } else if (leftPosition30 > 3) {
                pixelContainer30.removeChild(pixel30)
            }

        }, duration30 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel30, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel31() {
    const pixel31 = document.createElement('div');
    pixel31.classList.add('pixel31');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition31 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel31.style.left = `${leftPosition31}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor31 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel31.style.backgroundColor = randomColor31;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights31[leftPosition31]) {
        stackHeights31[leftPosition31] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration31 = Math.random() * 2;
    pixel31.style.animationDuration = `${duration31}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition31 < 3) {
        pixelContainer31.appendChild(pixel31);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel31.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel31.style.bottom = `${stackHeights31[leftPosition31]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights31[leftPosition31] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights31[leftPosition31] > 61) {
                pixelContainer31.removeChild(pixel31)
            } else if (leftPosition31 > 3) {
                pixelContainer31.removeChild(pixel31)
            }

        }, duration31 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel31, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel32() {
    const pixel32 = document.createElement('div');
    pixel32.classList.add('pixel32');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition32 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel32.style.left = `${leftPosition32}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor32 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel32.style.backgroundColor = randomColor32;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights32[leftPosition32]) {
        stackHeights32[leftPosition32] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration32 = Math.random() * 2;
    pixel32.style.animationDuration = `${duration32}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition32 < 3) {
        pixelContainer32.appendChild(pixel32);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel32.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel32.style.bottom = `${stackHeights32[leftPosition32]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights32[leftPosition32] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights32[leftPosition32] > 61) {
                pixelContainer32.removeChild(pixel32)
            } else if (leftPosition32 > 3) {
                pixelContainer32.removeChild(pixel32)
            }

        }, duration32 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel32, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel33() {
    const pixel33 = document.createElement('div');
    pixel33.classList.add('pixel33');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition33 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel33.style.left = `${leftPosition33}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor33 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel33.style.backgroundColor = randomColor33;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights33[leftPosition33]) {
        stackHeights33[leftPosition33] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration33 = Math.random() * 2;
    pixel33.style.animationDuration = `${duration33}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition33 < 3) {
        pixelContainer33.appendChild(pixel33);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel33.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel33.style.bottom = `${stackHeights33[leftPosition33]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights33[leftPosition33] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights33[leftPosition33] > 61) {
                pixelContainer33.removeChild(pixel33)
            } else if (leftPosition33 > 3) {
                pixelContainer33.removeChild(pixel33)
            }

        }, duration33 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel33, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel34() {
    const pixel34 = document.createElement('div');
    pixel34.classList.add('pixel34');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition34 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel34.style.left = `${leftPosition34}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor34 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel34.style.backgroundColor = randomColor34;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights34[leftPosition34]) {
        stackHeights34[leftPosition34] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration34 = Math.random() * 2;
    pixel34.style.animationDuration = `${duration34}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition34 < 3) {
        pixelContainer34.appendChild(pixel34);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel34.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel34.style.bottom = `${stackHeights34[leftPosition34]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights34[leftPosition34] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights34[leftPosition34] > 61) {
                pixelContainer34.removeChild(pixel34)
            } else if (leftPosition34 > 3) {
                pixelContainer34.removeChild(pixel34)
            }

        }, duration34 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel34, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel35() {
    const pixel35 = document.createElement('div');
    pixel35.classList.add('pixel35');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition35 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel35.style.left = `${leftPosition35}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor35 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel35.style.backgroundColor = randomColor35;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights35[leftPosition35]) {
        stackHeights35[leftPosition35] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration35 = Math.random() * 2;
    pixel35.style.animationDuration = `${duration35}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition35 < 3) {
        pixelContainer35.appendChild(pixel35);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel35.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel35.style.bottom = `${stackHeights35[leftPosition35]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights35[leftPosition35] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights35[leftPosition35] > 61) {
                pixelContainer35.removeChild(pixel35)
            } else if (leftPosition35 > 3) {
                pixelContainer35.removeChild(pixel35)
            }

        }, duration35 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel35, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel36() {
    const pixel36 = document.createElement('div');
    pixel36.classList.add('pixel36');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition36 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel36.style.left = `${leftPosition36}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor36 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel36.style.backgroundColor = randomColor36;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights36[leftPosition36]) {
        stackHeights36[leftPosition36] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration36 = Math.random() * 2;
    pixel36.style.animationDuration = `${duration36}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition36 < 3) {
        pixelContainer36.appendChild(pixel36);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel36.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel36.style.bottom = `${stackHeights36[leftPosition36]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights36[leftPosition36] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights36[leftPosition36] > 61) {
                pixelContainer36.removeChild(pixel36)
            } else if (leftPosition36 > 3) {
                pixelContainer36.removeChild(pixel36)
            }

        }, duration36 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel36, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel37() {
    const pixel37 = document.createElement('div');
    pixel37.classList.add('pixel37');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition37 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel37.style.left = `${leftPosition37}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor37 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel37.style.backgroundColor = randomColor37;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights37[leftPosition37]) {
        stackHeights37[leftPosition37] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration37 = Math.random() * 2;
    pixel37.style.animationDuration = `${duration37}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition37 < 3) {
        pixelContainer37.appendChild(pixel37);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel37.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel37.style.bottom = `${stackHeights37[leftPosition37]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights37[leftPosition37] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights37[leftPosition37] > 61) {
                pixelContainer37.removeChild(pixel37)
            } else if (leftPosition37 > 3) {
                pixelContainer37.removeChild(pixel37)
            }

        }, duration37 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel37, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel38() {
    const pixel38 = document.createElement('div');
    pixel38.classList.add('pixel38');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition38 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel38.style.left = `${leftPosition38}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor38 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel38.style.backgroundColor = randomColor38;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights38[leftPosition38]) {
        stackHeights38[leftPosition38] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration38 = Math.random() * 2;
    pixel38.style.animationDuration = `${duration38}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition38 < 3) {
        pixelContainer38.appendChild(pixel38);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel38.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel38.style.bottom = `${stackHeights38[leftPosition38]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights38[leftPosition38] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights38[leftPosition38] > 61) {
                pixelContainer38.removeChild(pixel38)
            } else if (leftPosition38 > 3) {
                pixelContainer38.removeChild(pixel38)
            }

        }, duration38 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel38, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel39() {
    const pixel39 = document.createElement('div');
    pixel39.classList.add('pixel39');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition39 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel39.style.left = `${leftPosition39}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor39 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel39.style.backgroundColor = randomColor39;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights39[leftPosition39]) {
        stackHeights39[leftPosition39] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration39 = Math.random() * 2;
    pixel39.style.animationDuration = `${duration39}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition39 < 3) {
        pixelContainer39.appendChild(pixel39);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel39.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel39.style.bottom = `${stackHeights39[leftPosition39]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights39[leftPosition39] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights39[leftPosition39] > 61) {
                pixelContainer39.removeChild(pixel39)
            } else if (leftPosition39 > 3) {
                pixelContainer39.removeChild(pixel39)
            }

        }, duration39 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel39, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel40() {
    const pixel40 = document.createElement('div');
    pixel40.classList.add('pixel40');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition40 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel40.style.left = `${leftPosition40}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor40 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel40.style.backgroundColor = randomColor40;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights40[leftPosition40]) {
        stackHeights40[leftPosition40] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration40 = Math.random() * 2;
    pixel40.style.animationDuration = `${duration40}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition40 < 3) {
        pixelContainer40.appendChild(pixel40);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel40.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel40.style.bottom = `${stackHeights40[leftPosition40]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights40[leftPosition40] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights40[leftPosition40] > 61) {
                pixelContainer40.removeChild(pixel40)
            } else if (leftPosition40 > 3) {
                pixelContainer40.removeChild(pixel40)
            }

        }, duration40 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel40, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel41() {
    const pixel41 = document.createElement('div');
    pixel41.classList.add('pixel41');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition41 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel41.style.left = `${leftPosition41}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor41 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel41.style.backgroundColor = randomColor41;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights41[leftPosition41]) {
        stackHeights41[leftPosition41] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration41 = Math.random() * 2;
    pixel41.style.animationDuration = `${duration41}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition41 < 3) {
        pixelContainer41.appendChild(pixel41);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel41.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel41.style.bottom = `${stackHeights41[leftPosition41]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights41[leftPosition41] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights41[leftPosition41] > 61) {
                pixelContainer41.removeChild(pixel41)
            } else if (leftPosition41 > 3) {
                pixelContainer41.removeChild(pixel41)
            }

        }, duration41 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel41, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel42() {
    const pixel42 = document.createElement('div');
    pixel42.classList.add('pixel42');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition42 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel42.style.left = `${leftPosition42}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor42 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel42.style.backgroundColor = randomColor42;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights42[leftPosition42]) {
        stackHeights42[leftPosition42] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration42 = Math.random() * 2;
    pixel42.style.animationDuration = `${duration42}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition42 < 3) {
        pixelContainer42.appendChild(pixel42);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel42.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel42.style.bottom = `${stackHeights42[leftPosition42]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights42[leftPosition42] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights42[leftPosition42] > 61) {
                pixelContainer42.removeChild(pixel42)
            } else if (leftPosition42 > 3) {
                pixelContainer42.removeChild(pixel42)
            }

        }, duration42 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel42, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel43() {
    const pixel43 = document.createElement('div');
    pixel43.classList.add('pixel43');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition43 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel43.style.left = `${leftPosition43}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor43 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel43.style.backgroundColor = randomColor43;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights43[leftPosition43]) {
        stackHeights43[leftPosition43] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration43 = Math.random() * 2;
    pixel43.style.animationDuration = `${duration43}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition43 < 3) {
        pixelContainer43.appendChild(pixel43);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel43.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel43.style.bottom = `${stackHeights43[leftPosition43]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights43[leftPosition43] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights43[leftPosition43] > 61) {
                pixelContainer43.removeChild(pixel43)
            } else if (leftPosition43 > 3) {
                pixelContainer43.removeChild(pixel43)
            }

        }, duration43 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel43, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel44() {
    const pixel44 = document.createElement('div');
    pixel44.classList.add('pixel44');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition44 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel44.style.left = `${leftPosition44}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor44 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel44.style.backgroundColor = randomColor44;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights44[leftPosition44]) {
        stackHeights44[leftPosition44] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration44 = Math.random() * 2;
    pixel44.style.animationDuration = `${duration44}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition44 < 3) {
        pixelContainer44.appendChild(pixel44);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel44.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel44.style.bottom = `${stackHeights44[leftPosition44]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights44[leftPosition44] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights44[leftPosition44] > 61) {
                pixelContainer44.removeChild(pixel44)
            } else if (leftPosition44 > 3) {
                pixelContainer44.removeChild(pixel44)
            }

        }, duration44 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel44, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel45() {
    const pixel45 = document.createElement('div');
    pixel45.classList.add('pixel45');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition45 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel45.style.left = `${leftPosition45}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor45 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel45.style.backgroundColor = randomColor45;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights45[leftPosition45]) {
        stackHeights45[leftPosition45] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration45 = Math.random() * 2;
    pixel45.style.animationDuration = `${duration45}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition45 < 3) {
        pixelContainer45.appendChild(pixel45);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel45.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel45.style.bottom = `${stackHeights45[leftPosition45]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights45[leftPosition45] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights45[leftPosition45] > 61) {
                pixelContainer45.removeChild(pixel45)
            } else if (leftPosition45 > 3) {
                pixelContainer45.removeChild(pixel45)
            }

        }, duration45 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel45, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel46() {
    const pixel46 = document.createElement('div');
    pixel46.classList.add('pixel46');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition46 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel46.style.left = `${leftPosition46}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor46 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel46.style.backgroundColor = randomColor46;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights46[leftPosition46]) {
        stackHeights46[leftPosition46] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration46 = Math.random() * 2;
    pixel46.style.animationDuration = `${duration46}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition46 < 3) {
        pixelContainer46.appendChild(pixel46);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel46.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel46.style.bottom = `${stackHeights46[leftPosition46]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights46[leftPosition46] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights46[leftPosition46] > 61) {
                pixelContainer46.removeChild(pixel46)
            } else if (leftPosition46 > 3) {
                pixelContainer46.removeChild(pixel46)
            }

        }, duration46 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel46, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel47() {
    const pixel47 = document.createElement('div');
    pixel47.classList.add('pixel47');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition47 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel47.style.left = `${leftPosition47}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor47 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel47.style.backgroundColor = randomColor47;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights47[leftPosition47]) {
        stackHeights47[leftPosition47] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration47 = Math.random() * 2;
    pixel47.style.animationDuration = `${duration47}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition47 < 3) {
        pixelContainer47.appendChild(pixel47);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel47.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel47.style.bottom = `${stackHeights47[leftPosition47]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights47[leftPosition47] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights47[leftPosition47] > 61) {
                pixelContainer47.removeChild(pixel47)
            } else if (leftPosition47 > 3) {
                pixelContainer47.removeChild(pixel47)
            }

        }, duration47 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel47, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel48() {
    const pixel48 = document.createElement('div');
    pixel48.classList.add('pixel48');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition48 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel48.style.left = `${leftPosition48}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor48 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel48.style.backgroundColor = randomColor48;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights48[leftPosition48]) {
        stackHeights48[leftPosition48] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration48 = Math.random() * 2;
    pixel48.style.animationDuration = `${duration48}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition48 < 3) {
        pixelContainer48.appendChild(pixel48);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel48.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel48.style.bottom = `${stackHeights48[leftPosition48]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights48[leftPosition48] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights48[leftPosition48] > 61) {
                pixelContainer48.removeChild(pixel48)
            } else if (leftPosition48 > 3) {
                pixelContainer48.removeChild(pixel48)
            }

        }, duration48 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel48, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel49() {
    const pixel49 = document.createElement('div');
    pixel49.classList.add('pixel49');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition49 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel49.style.left = `${leftPosition49}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor49 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel49.style.backgroundColor = randomColor49;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights49[leftPosition49]) {
        stackHeights49[leftPosition49] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration49 = Math.random() * 2;
    pixel49.style.animationDuration = `${duration49}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition49 < 3) {
        pixelContainer49.appendChild(pixel49);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel49.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel49.style.bottom = `${stackHeights49[leftPosition49]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights49[leftPosition49] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights49[leftPosition49] > 61) {
                pixelContainer49.removeChild(pixel49)
            } else if (leftPosition49 > 3) {
                pixelContainer49.removeChild(pixel49)
            }

        }, duration49 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel49, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel50() {
    const pixel50 = document.createElement('div');
    pixel50.classList.add('pixel50');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition50 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel50.style.left = `${leftPosition50}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor50 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel50.style.backgroundColor = randomColor50;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights50[leftPosition50]) {
        stackHeights50[leftPosition50] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration50 = Math.random() * 2;
    pixel50.style.animationDuration = `${duration50}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition50 < 3) {
        pixelContainer50.appendChild(pixel50);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel50.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel50.style.bottom = `${stackHeights50[leftPosition50]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights50[leftPosition50] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights50[leftPosition50] > 61) {
                pixelContainer50.removeChild(pixel50)
            } else if (leftPosition50 > 3) {
                pixelContainer50.removeChild(pixel50)
            }

        }, duration50 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel50, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel51() {
    const pixel51 = document.createElement('div');
    pixel51.classList.add('pixel51');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition51 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel51.style.left = `${leftPosition51}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor51 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel51.style.backgroundColor = randomColor51;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights51[leftPosition51]) {
        stackHeights51[leftPosition51] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration51 = Math.random() * 2;
    pixel51.style.animationDuration = `${duration51}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition51 < 3) {
        pixelContainer51.appendChild(pixel51);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel51.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel51.style.bottom = `${stackHeights51[leftPosition51]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights51[leftPosition51] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights51[leftPosition51] > 61) {
                pixelContainer51.removeChild(pixel51)
            } else if (leftPosition51 > 3) {
                pixelContainer51.removeChild(pixel51)
            }

        }, duration51 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel51, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel52() {
    const pixel52 = document.createElement('div');
    pixel52.classList.add('pixel52');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition52 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel52.style.left = `${leftPosition52}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor52 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel52.style.backgroundColor = randomColor52;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights52[leftPosition52]) {
        stackHeights52[leftPosition52] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration52 = Math.random() * 2;
    pixel52.style.animationDuration = `${duration52}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition52 < 3) {
        pixelContainer52.appendChild(pixel52);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel52.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel52.style.bottom = `${stackHeights52[leftPosition52]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights52[leftPosition52] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights52[leftPosition52] > 61) {
                pixelContainer52.removeChild(pixel52)
            } else if (leftPosition52 > 3) {
                pixelContainer52.removeChild(pixel52)
            }

        }, duration52 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel52, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel53() {
    const pixel53 = document.createElement('div');
    pixel53.classList.add('pixel53');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition53 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel53.style.left = `${leftPosition53}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor53 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel53.style.backgroundColor = randomColor53;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights53[leftPosition53]) {
        stackHeights53[leftPosition53] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration53 = Math.random() * 2;
    pixel53.style.animationDuration = `${duration53}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition53 < 3) {
        pixelContainer53.appendChild(pixel53);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel53.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel53.style.bottom = `${stackHeights53[leftPosition53]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights53[leftPosition53] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights53[leftPosition53] > 61) {
                pixelContainer53.removeChild(pixel53)
            } else if (leftPosition53 > 3) {
                pixelContainer53.removeChild(pixel53)
            }

        }, duration53 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel53, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel54() {
    const pixel54 = document.createElement('div');
    pixel54.classList.add('pixel54');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition54 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel54.style.left = `${leftPosition54}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor54 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel54.style.backgroundColor = randomColor54;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights54[leftPosition54]) {
        stackHeights54[leftPosition54] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration54 = Math.random() * 2;
    pixel54.style.animationDuration = `${duration54}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition54 < 3) {
        pixelContainer54.appendChild(pixel54);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel54.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel54.style.bottom = `${stackHeights54[leftPosition54]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights54[leftPosition54] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights54[leftPosition54] > 61) {
                pixelContainer54.removeChild(pixel54)
            } else if (leftPosition54 > 3) {
                pixelContainer54.removeChild(pixel54)
            }

        }, duration54 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel54, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel55() {
    const pixel55 = document.createElement('div');
    pixel55.classList.add('pixel55');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition55 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel55.style.left = `${leftPosition55}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor55 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel55.style.backgroundColor = randomColor55;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights55[leftPosition55]) {
        stackHeights55[leftPosition55] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration55 = Math.random() * 2;
    pixel55.style.animationDuration = `${duration55}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition55 < 3) {
        pixelContainer55.appendChild(pixel55);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel55.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel55.style.bottom = `${stackHeights55[leftPosition55]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights55[leftPosition55] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights55[leftPosition55] > 61) {
                pixelContainer55.removeChild(pixel55)
            } else if (leftPosition55 > 3) {
                pixelContainer55.removeChild(pixel55)
            }

        }, duration55 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel55, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel56() {
    const pixel56 = document.createElement('div');
    pixel56.classList.add('pixel56');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition56 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel56.style.left = `${leftPosition56}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor56 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel56.style.backgroundColor = randomColor56;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights56[leftPosition56]) {
        stackHeights56[leftPosition56] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration56 = Math.random() * 2;
    pixel56.style.animationDuration = `${duration56}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition56 < 3) {
        pixelContainer56.appendChild(pixel56);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel56.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel56.style.bottom = `${stackHeights56[leftPosition56]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights56[leftPosition56] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights56[leftPosition56] > 61) {
                pixelContainer56.removeChild(pixel56)
            } else if (leftPosition56 > 3) {
                pixelContainer56.removeChild(pixel56)
            }

        }, duration56 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel56, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel57() {
    const pixel57 = document.createElement('div');
    pixel57.classList.add('pixel57');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition57 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel57.style.left = `${leftPosition57}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor57 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel57.style.backgroundColor = randomColor57;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights57[leftPosition57]) {
        stackHeights57[leftPosition57] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration57 = Math.random() * 2;
    pixel57.style.animationDuration = `${duration57}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition57 < 3) {
        pixelContainer57.appendChild(pixel57);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel57.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel57.style.bottom = `${stackHeights57[leftPosition57]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights57[leftPosition57] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights57[leftPosition57] > 61) {
                pixelContainer57.removeChild(pixel57)
            } else if (leftPosition57 > 3) {
                pixelContainer57.removeChild(pixel57)
            }

        }, duration57 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel57, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel58() {
    const pixel58 = document.createElement('div');
    pixel58.classList.add('pixel58');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition58 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel58.style.left = `${leftPosition58}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor58 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel58.style.backgroundColor = randomColor58;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights58[leftPosition58]) {
        stackHeights58[leftPosition58] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration58 = Math.random() * 2;
    pixel58.style.animationDuration = `${duration58}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition58 < 3) {
        pixelContainer58.appendChild(pixel58);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel58.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel58.style.bottom = `${stackHeights58[leftPosition58]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights58[leftPosition58] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights58[leftPosition58] > 61) {
                pixelContainer58.removeChild(pixel58)
            } else if (leftPosition58 > 3) {
                pixelContainer58.removeChild(pixel58)
            }

        }, duration58 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel58, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel59() {
    const pixel59 = document.createElement('div');
    pixel59.classList.add('pixel59');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition59 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel59.style.left = `${leftPosition59}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor59 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel59.style.backgroundColor = randomColor59;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights59[leftPosition59]) {
        stackHeights59[leftPosition59] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration59 = Math.random() * 2;
    pixel59.style.animationDuration = `${duration59}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition59 < 3) {
        pixelContainer59.appendChild(pixel59);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel59.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel59.style.bottom = `${stackHeights59[leftPosition59]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights59[leftPosition59] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights59[leftPosition59] > 61) {
                pixelContainer59.removeChild(pixel59)
            } else if (leftPosition59 > 3) {
                pixelContainer59.removeChild(pixel59)
            }

        }, duration59 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel59, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel60() {
    const pixel60 = document.createElement('div');
    pixel60.classList.add('pixel60');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition60 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel60.style.left = `${leftPosition60}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor60 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel60.style.backgroundColor = randomColor60;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights60[leftPosition60]) {
        stackHeights60[leftPosition60] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration60 = Math.random() * 2;
    pixel60.style.animationDuration = `${duration60}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition60 < 3) {
        pixelContainer60.appendChild(pixel60);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel60.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel60.style.bottom = `${stackHeights60[leftPosition60]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights60[leftPosition60] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights60[leftPosition60] > 61) {
                pixelContainer60.removeChild(pixel60)
            } else if (leftPosition60 > 3) {
                pixelContainer60.removeChild(pixel60)
            }

        }, duration60 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel60, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel61() {
    const pixel61 = document.createElement('div');
    pixel61.classList.add('pixel61');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition61 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel61.style.left = `${leftPosition61}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor61 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel61.style.backgroundColor = randomColor61;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights61[leftPosition61]) {
        stackHeights61[leftPosition61] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration61 = Math.random() * 2;
    pixel61.style.animationDuration = `${duration61}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition61 < 3) {
        pixelContainer61.appendChild(pixel61);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel61.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel61.style.bottom = `${stackHeights61[leftPosition61]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights61[leftPosition61] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights61[leftPosition61] > 61) {
                pixelContainer61.removeChild(pixel61)
            } else if (leftPosition61 > 3) {
                pixelContainer61.removeChild(pixel61)
            }

        }, duration61 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel61, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel62() {
    const pixel62 = document.createElement('div');
    pixel62.classList.add('pixel62');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition62 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel62.style.left = `${leftPosition62}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor62 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel62.style.backgroundColor = randomColor62;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights62[leftPosition62]) {
        stackHeights62[leftPosition62] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration62 = Math.random() * 2;
    pixel62.style.animationDuration = `${duration62}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition62 < 3) {
        pixelContainer62.appendChild(pixel62);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel62.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel62.style.bottom = `${stackHeights62[leftPosition62]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights62[leftPosition62] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights62[leftPosition62] > 61) {
                pixelContainer62.removeChild(pixel62)
            } else if (leftPosition62 > 3) {
                pixelContainer62.removeChild(pixel62)
            }

        }, duration62 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel62, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel63() {
    const pixel63 = document.createElement('div');
    pixel63.classList.add('pixel63');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition63 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel63.style.left = `${leftPosition63}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor63 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel63.style.backgroundColor = randomColor63;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights63[leftPosition63]) {
        stackHeights63[leftPosition63] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration63 = Math.random() * 2;
    pixel63.style.animationDuration = `${duration63}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition63 < 3) {
        pixelContainer63.appendChild(pixel63);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel63.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel63.style.bottom = `${stackHeights63[leftPosition63]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights63[leftPosition63] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights63[leftPosition63] > 61) {
                pixelContainer63.removeChild(pixel63)
            } else if (leftPosition63 > 3) {
                pixelContainer63.removeChild(pixel63)
            }

        }, duration63 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel63, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel64() {
    const pixel64 = document.createElement('div');
    pixel64.classList.add('pixel64');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition64 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel64.style.left = `${leftPosition64}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor64 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel64.style.backgroundColor = randomColor64;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights64[leftPosition64]) {
        stackHeights64[leftPosition64] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration64 = Math.random() * 2;
    pixel64.style.animationDuration = `${duration64}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition64 < 3) {
        pixelContainer64.appendChild(pixel64);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel64.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel64.style.bottom = `${stackHeights64[leftPosition64]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights64[leftPosition64] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights64[leftPosition64] > 61) {
                pixelContainer64.removeChild(pixel64)
            } else if (leftPosition64 > 3) {
                pixelContainer64.removeChild(pixel64)
            }

        }, duration64 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel64, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel65() {
    const pixel65 = document.createElement('div');
    pixel65.classList.add('pixel65');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition65 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel65.style.left = `${leftPosition65}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor65 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel65.style.backgroundColor = randomColor65;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights65[leftPosition65]) {
        stackHeights65[leftPosition65] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration65 = Math.random() * 2;
    pixel65.style.animationDuration = `${duration65}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition65 < 3) {
        pixelContainer65.appendChild(pixel65);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel65.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel65.style.bottom = `${stackHeights65[leftPosition65]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights65[leftPosition65] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights65[leftPosition65] > 61) {
                pixelContainer65.removeChild(pixel65)
            } else if (leftPosition65 > 3) {
                pixelContainer65.removeChild(pixel65)
            }

        }, duration65 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel65, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel66() {
    const pixel66 = document.createElement('div');
    pixel66.classList.add('pixel66');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition66 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel66.style.left = `${leftPosition66}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor66 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel66.style.backgroundColor = randomColor66;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights66[leftPosition66]) {
        stackHeights66[leftPosition66] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration66 = Math.random() * 2;
    pixel66.style.animationDuration = `${duration66}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition66 < 3) {
        pixelContainer66.appendChild(pixel66);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel66.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel66.style.bottom = `${stackHeights66[leftPosition66]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights66[leftPosition66] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights66[leftPosition66] > 61) {
                pixelContainer66.removeChild(pixel66)
            } else if (leftPosition66 > 3) {
                pixelContainer66.removeChild(pixel66)
            }

        }, duration66 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel66, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel67() {
    const pixel67 = document.createElement('div');
    pixel67.classList.add('pixel67');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition67 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel67.style.left = `${leftPosition67}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor67 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel67.style.backgroundColor = randomColor67;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights67[leftPosition67]) {
        stackHeights67[leftPosition67] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration67 = Math.random() * 2;
    pixel67.style.animationDuration = `${duration67}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition67 < 3) {
        pixelContainer67.appendChild(pixel67);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel67.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel67.style.bottom = `${stackHeights67[leftPosition67]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights67[leftPosition67] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights67[leftPosition67] > 61) {
                pixelContainer67.removeChild(pixel67)
            } else if (leftPosition67 > 3) {
                pixelContainer67.removeChild(pixel67)
            }

        }, duration67 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel67, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel68() {
    const pixel68 = document.createElement('div');
    pixel68.classList.add('pixel68');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition68 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel68.style.left = `${leftPosition68}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor68 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel68.style.backgroundColor = randomColor68;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights68[leftPosition68]) {
        stackHeights68[leftPosition68] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration68 = Math.random() * 2;
    pixel68.style.animationDuration = `${duration68}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition68 < 3) {
        pixelContainer68.appendChild(pixel68);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel68.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel68.style.bottom = `${stackHeights68[leftPosition68]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights68[leftPosition68] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights68[leftPosition68] > 61) {
                pixelContainer68.removeChild(pixel68)
            } else if (leftPosition68 > 3) {
                pixelContainer68.removeChild(pixel68)
            }

        }, duration68 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel68, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel69() {
    const pixel69 = document.createElement('div');
    pixel69.classList.add('pixel69');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition69 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel69.style.left = `${leftPosition69}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor69 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel69.style.backgroundColor = randomColor69;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights69[leftPosition69]) {
        stackHeights69[leftPosition69] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration69 = Math.random() * 2;
    pixel69.style.animationDuration = `${duration69}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition69 < 3) {
        pixelContainer69.appendChild(pixel69);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel69.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel69.style.bottom = `${stackHeights69[leftPosition69]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights69[leftPosition69] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights69[leftPosition69] > 61) {
                pixelContainer69.removeChild(pixel69)
            } else if (leftPosition69 > 3) {
                pixelContainer69.removeChild(pixel69)
            }

        }, duration69 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel69, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel70() {
    const pixel70 = document.createElement('div');
    pixel70.classList.add('pixel70');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition70 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel70.style.left = `${leftPosition70}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor70 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel70.style.backgroundColor = randomColor70;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights70[leftPosition70]) {
        stackHeights70[leftPosition70] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration70 = Math.random() * 2;
    pixel70.style.animationDuration = `${duration70}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition70 < 3) {
        pixelContainer70.appendChild(pixel70);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel70.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel70.style.bottom = `${stackHeights70[leftPosition70]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights70[leftPosition70] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights70[leftPosition70] > 61) {
                pixelContainer70.removeChild(pixel70)
            } else if (leftPosition70 > 3) {
                pixelContainer70.removeChild(pixel70)
            }

        }, duration70 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel70, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel71() {
    const pixel71 = document.createElement('div');
    pixel71.classList.add('pixel71');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition71 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel71.style.left = `${leftPosition71}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor71 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel71.style.backgroundColor = randomColor71;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights71[leftPosition71]) {
        stackHeights71[leftPosition71] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration71 = Math.random() * 2;
    pixel71.style.animationDuration = `${duration71}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition71 < 3) {
        pixelContainer71.appendChild(pixel71);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel71.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel71.style.bottom = `${stackHeights71[leftPosition71]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights71[leftPosition71] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights71[leftPosition71] > 61) {
                pixelContainer71.removeChild(pixel71)
            } else if (leftPosition71 > 3) {
                pixelContainer71.removeChild(pixel71)
            }

        }, duration71 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel71, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel72() {
    const pixel72 = document.createElement('div');
    pixel72.classList.add('pixel72');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition72 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel72.style.left = `${leftPosition72}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor72 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel72.style.backgroundColor = randomColor72;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights72[leftPosition72]) {
        stackHeights72[leftPosition72] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration72 = Math.random() * 2;
    pixel72.style.animationDuration = `${duration72}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition72 < 3) {
        pixelContainer72.appendChild(pixel72);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel72.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel72.style.bottom = `${stackHeights72[leftPosition72]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights72[leftPosition72] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights72[leftPosition72] > 61) {
                pixelContainer72.removeChild(pixel72)
            } else if (leftPosition72 > 3) {
                pixelContainer72.removeChild(pixel72)
            }

        }, duration72 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel72, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel73() {
    const pixel73 = document.createElement('div');
    pixel73.classList.add('pixel73');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition73 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel73.style.left = `${leftPosition73}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor73 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel73.style.backgroundColor = randomColor73;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights73[leftPosition73]) {
        stackHeights73[leftPosition73] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration73 = Math.random() * 2;
    pixel73.style.animationDuration = `${duration73}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition73 < 3) {
        pixelContainer73.appendChild(pixel73);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel73.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel73.style.bottom = `${stackHeights73[leftPosition73]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights73[leftPosition73] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights73[leftPosition73] > 61) {
                pixelContainer73.removeChild(pixel73)
            } else if (leftPosition73 > 3) {
                pixelContainer73.removeChild(pixel73)
            }

        }, duration73 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel73, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel74() {
    const pixel74 = document.createElement('div');
    pixel74.classList.add('pixel74');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition74 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel74.style.left = `${leftPosition74}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor74 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel74.style.backgroundColor = randomColor74;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights74[leftPosition74]) {
        stackHeights74[leftPosition74] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration74 = Math.random() * 2;
    pixel74.style.animationDuration = `${duration74}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition74 < 3) {
        pixelContainer74.appendChild(pixel74);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel74.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel74.style.bottom = `${stackHeights74[leftPosition74]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights74[leftPosition74] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights74[leftPosition74] > 61) {
                pixelContainer74.removeChild(pixel74)
            } else if (leftPosition74 > 3) {
                pixelContainer74.removeChild(pixel74)
            }

        }, duration74 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel74, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel75() {
    const pixel75 = document.createElement('div');
    pixel75.classList.add('pixel75');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition75 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel75.style.left = `${leftPosition75}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor75 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel75.style.backgroundColor = randomColor75;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights75[leftPosition75]) {
        stackHeights75[leftPosition75] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration75 = Math.random() * 2;
    pixel75.style.animationDuration = `${duration75}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition75 < 3) {
        pixelContainer75.appendChild(pixel75);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel75.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel75.style.bottom = `${stackHeights75[leftPosition75]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights75[leftPosition75] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights75[leftPosition75] > 61) {
                pixelContainer75.removeChild(pixel75)
            } else if (leftPosition75 > 3) {
                pixelContainer75.removeChild(pixel75)
            }

        }, duration75 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel75, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel76() {
    const pixel76 = document.createElement('div');
    pixel76.classList.add('pixel76');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition76 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel76.style.left = `${leftPosition76}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor76 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel76.style.backgroundColor = randomColor76;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights76[leftPosition76]) {
        stackHeights76[leftPosition76] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration76 = Math.random() * 2;
    pixel76.style.animationDuration = `${duration76}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition76 < 3) {
        pixelContainer76.appendChild(pixel76);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel76.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel76.style.bottom = `${stackHeights76[leftPosition76]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights76[leftPosition76] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights76[leftPosition76] > 61) {
                pixelContainer76.removeChild(pixel76)
            } else if (leftPosition76 > 3) {
                pixelContainer76.removeChild(pixel76)
            }

        }, duration76 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel76, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel77() {
    const pixel77 = document.createElement('div');
    pixel77.classList.add('pixel77');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition77 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel77.style.left = `${leftPosition77}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor77 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel77.style.backgroundColor = randomColor77;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights77[leftPosition77]) {
        stackHeights77[leftPosition77] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration77 = Math.random() * 2;
    pixel77.style.animationDuration = `${duration77}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition77 < 3) {
        pixelContainer77.appendChild(pixel77);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel77.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel77.style.bottom = `${stackHeights77[leftPosition77]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights77[leftPosition77] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights77[leftPosition77] > 61) {
                pixelContainer77.removeChild(pixel77)
            } else if (leftPosition77 > 3) {
                pixelContainer77.removeChild(pixel77)
            }

        }, duration77 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel77, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel78() {
    const pixel78 = document.createElement('div');
    pixel78.classList.add('pixel78');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition78 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel78.style.left = `${leftPosition78}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor78 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel78.style.backgroundColor = randomColor78;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights78[leftPosition78]) {
        stackHeights78[leftPosition78] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration78 = Math.random() * 2;
    pixel78.style.animationDuration = `${duration78}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition78 < 3) {
        pixelContainer78.appendChild(pixel78);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel78.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel78.style.bottom = `${stackHeights78[leftPosition78]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights78[leftPosition78] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights78[leftPosition78] > 61) {
                pixelContainer78.removeChild(pixel78)
            } else if (leftPosition78 > 3) {
                pixelContainer78.removeChild(pixel78)
            }

        }, duration78 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel78, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel79() {
    const pixel79 = document.createElement('div');
    pixel79.classList.add('pixel79');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition79 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel79.style.left = `${leftPosition79}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor79 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel79.style.backgroundColor = randomColor79;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights79[leftPosition79]) {
        stackHeights79[leftPosition79] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration79 = Math.random() * 2;
    pixel79.style.animationDuration = `${duration79}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition79 < 3) {
        pixelContainer79.appendChild(pixel79);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel79.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel79.style.bottom = `${stackHeights79[leftPosition79]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights79[leftPosition79] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights79[leftPosition79] > 61) {
                pixelContainer79.removeChild(pixel79)
            } else if (leftPosition79 > 3) {
                pixelContainer79.removeChild(pixel79)
            }

        }, duration79 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel79, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel80() {
    const pixel80 = document.createElement('div');
    pixel80.classList.add('pixel80');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition80 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel80.style.left = `${leftPosition80}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor80 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel80.style.backgroundColor = randomColor80;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights80[leftPosition80]) {
        stackHeights80[leftPosition80] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration80 = Math.random() * 2;
    pixel80.style.animationDuration = `${duration80}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition80 < 3) {
        pixelContainer80.appendChild(pixel80);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel80.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel80.style.bottom = `${stackHeights80[leftPosition80]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights80[leftPosition80] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights80[leftPosition80] > 61) {
                pixelContainer80.removeChild(pixel80)
            } else if (leftPosition80 > 3) {
                pixelContainer80.removeChild(pixel80)
            }

        }, duration80 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel80, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel81() {
    const pixel81 = document.createElement('div');
    pixel81.classList.add('pixel81');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition81 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel81.style.left = `${leftPosition81}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor81 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel81.style.backgroundColor = randomColor81;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights81[leftPosition81]) {
        stackHeights81[leftPosition81] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration81 = Math.random() * 2;
    pixel81.style.animationDuration = `${duration81}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition81 < 3) {
        pixelContainer81.appendChild(pixel81);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel81.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel81.style.bottom = `${stackHeights81[leftPosition81]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights81[leftPosition81] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights81[leftPosition81] > 61) {
                pixelContainer81.removeChild(pixel81)
            } else if (leftPosition81 > 3) {
                pixelContainer81.removeChild(pixel81)
            }

        }, duration81 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel81, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel82() {
    const pixel82 = document.createElement('div');
    pixel82.classList.add('pixel82');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition82 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel82.style.left = `${leftPosition82}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor82 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel82.style.backgroundColor = randomColor82;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights82[leftPosition82]) {
        stackHeights82[leftPosition82] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration82 = Math.random() * 2;
    pixel82.style.animationDuration = `${duration82}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition82 < 3) {
        pixelContainer82.appendChild(pixel82);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel82.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel82.style.bottom = `${stackHeights82[leftPosition82]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights82[leftPosition82] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights82[leftPosition82] > 61) {
                pixelContainer82.removeChild(pixel82)
            } else if (leftPosition82 > 3) {
                pixelContainer82.removeChild(pixel82)
            }

        }, duration82 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel82, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel83() {
    const pixel83 = document.createElement('div');
    pixel83.classList.add('pixel83');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition83 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel83.style.left = `${leftPosition83}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor83 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel83.style.backgroundColor = randomColor83;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights83[leftPosition83]) {
        stackHeights83[leftPosition83] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration83 = Math.random() * 2;
    pixel83.style.animationDuration = `${duration83}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition83 < 3) {
        pixelContainer83.appendChild(pixel83);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel83.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel83.style.bottom = `${stackHeights83[leftPosition83]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights83[leftPosition83] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights83[leftPosition83] > 61) {
                pixelContainer83.removeChild(pixel83)
            } else if (leftPosition83 > 3) {
                pixelContainer83.removeChild(pixel83)
            }

        }, duration83 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel83, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel84() {
    const pixel84 = document.createElement('div');
    pixel84.classList.add('pixel84');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition84 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel84.style.left = `${leftPosition84}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor84 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel84.style.backgroundColor = randomColor84;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights84[leftPosition84]) {
        stackHeights84[leftPosition84] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration84 = Math.random() * 2;
    pixel84.style.animationDuration = `${duration84}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition84 < 3) {
        pixelContainer84.appendChild(pixel84);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel84.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel84.style.bottom = `${stackHeights84[leftPosition84]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights84[leftPosition84] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights84[leftPosition84] > 61) {
                pixelContainer84.removeChild(pixel84)
            } else if (leftPosition84 > 3) {
                pixelContainer84.removeChild(pixel84)
            }

        }, duration84 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel84, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel85() {
    const pixel85 = document.createElement('div');
    pixel85.classList.add('pixel85');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition85 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel85.style.left = `${leftPosition85}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor85 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel85.style.backgroundColor = randomColor85;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights85[leftPosition85]) {
        stackHeights85[leftPosition85] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration85 = Math.random() * 2;
    pixel85.style.animationDuration = `${duration85}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition85 < 3) {
        pixelContainer85.appendChild(pixel85);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel85.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel85.style.bottom = `${stackHeights85[leftPosition85]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights85[leftPosition85] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights85[leftPosition85] > 61) {
                pixelContainer85.removeChild(pixel85)
            } else if (leftPosition85 > 3) {
                pixelContainer85.removeChild(pixel85)
            }

        }, duration85 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel85, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임




function createPixel86() {
    const pixel86 = document.createElement('div');
    pixel86.classList.add('pixel86');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition86 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel86.style.left = `${leftPosition86}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor86 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel86.style.backgroundColor = randomColor86;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights86[leftPosition86]) {
        stackHeights86[leftPosition86] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration86 = Math.random() * 2;
    pixel86.style.animationDuration = `${duration86}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition86 < 3) {
        pixelContainer86.appendChild(pixel86);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel86.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel86.style.bottom = `${stackHeights86[leftPosition86]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights86[leftPosition86] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights86[leftPosition86] > 61) {
                pixelContainer86.removeChild(pixel86)
            } else if (leftPosition86 > 3) {
                pixelContainer86.removeChild(pixel86)
            }

        }, duration86 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel86, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel87() {
    const pixel87 = document.createElement('div');
    pixel87.classList.add('pixel87');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition87 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel87.style.left = `${leftPosition87}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor87 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel87.style.backgroundColor = randomColor87;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights87[leftPosition87]) {
        stackHeights87[leftPosition87] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration87 = Math.random() * 2;
    pixel87.style.animationDuration = `${duration87}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition87 < 3) {
        pixelContainer87.appendChild(pixel87);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel87.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel87.style.bottom = `${stackHeights87[leftPosition87]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights87[leftPosition87] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights87[leftPosition87] > 61) {
                pixelContainer87.removeChild(pixel87)
            } else if (leftPosition87 > 3) {
                pixelContainer87.removeChild(pixel87)
            }

        }, duration87 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel87, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel88() {
    const pixel88 = document.createElement('div');
    pixel88.classList.add('pixel88');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition88 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel88.style.left = `${leftPosition88}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor88 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel88.style.backgroundColor = randomColor88;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights88[leftPosition88]) {
        stackHeights88[leftPosition88] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration88 = Math.random() * 2;
    pixel88.style.animationDuration = `${duration88}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition88 < 3) {
        pixelContainer88.appendChild(pixel88);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel88.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel88.style.bottom = `${stackHeights88[leftPosition88]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights88[leftPosition88] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights88[leftPosition88] > 61) {
                pixelContainer88.removeChild(pixel88)
            } else if (leftPosition88 > 3) {
                pixelContainer88.removeChild(pixel88)
            }

        }, duration88 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel88, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임




function createPixel89() {
    const pixel89 = document.createElement('div');
    pixel89.classList.add('pixel89');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition89 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel89.style.left = `${leftPosition89}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor89 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel89.style.backgroundColor = randomColor89;

    
    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights89[leftPosition89]) {
        stackHeights89[leftPosition89] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration89 = Math.random() * 2;
    pixel89.style.animationDuration = `${duration89}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition89 < 3) {
        pixelContainer89.appendChild(pixel89);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel89.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel89.style.bottom = `${stackHeights89[leftPosition89]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights89[leftPosition89] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights89[leftPosition89] > 61) {
                pixelContainer89.removeChild(pixel89)
            } else if (leftPosition89 > 3) {
                pixelContainer89.removeChild(pixel89)
            }

        }, duration89 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel89, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임




function createPixel90() {
    const pixel90 = document.createElement('div');
    pixel90.classList.add('pixel90');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition90 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel90.style.left = `${leftPosition90}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor90 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel90.style.backgroundColor = randomColor90;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights90[leftPosition90]) {
        stackHeights90[leftPosition90] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration90 = Math.random() * 2;
    pixel90.style.animationDuration = `${duration90}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition90 < 3) {
        pixelContainer90.appendChild(pixel90);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel90.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel90.style.bottom = `${stackHeights90[leftPosition90]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights90[leftPosition90] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights90[leftPosition90] > 61) {
                pixelContainer90.removeChild(pixel90)
            } else if (leftPosition90 > 3) {
                pixelContainer90.removeChild(pixel90)
            }

        }, duration90 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel90, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임



function createPixel91() {
    const pixel91 = document.createElement('div');
    pixel91.classList.add('pixel91');

    // 수평 위치를 더 세밀하게 설정 (0.1vw 단위로)
    const leftPosition91 = (Math.floor(Math.random() * 130) / 1.3).toFixed(1);
    pixel91.style.left = `${leftPosition91}vw`;

    // 픽셀의 색상을 랜덤으로 지정
    const randomColor91 = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    pixel91.style.backgroundColor = randomColor91;


    // 해당 위치에 쌓인 높이가 없으면 초기화
    if (!stackHeights91[leftPosition91]) {
        stackHeights91[leftPosition91] = 0;
    }

    // 픽셀들이 서로 다른 속도로 떨어지도록 랜덤한 애니메이션 지속 시간을 설정
    const duration91 = Math.random() * 2;
    pixel91.style.animationDuration = `${duration91}s`;

    // 픽셀을 컨테이너에 추가
    if (leftPosition91 < 3) {
        pixelContainer91.appendChild(pixel91);

        // 애니메이션이 끝나면 픽셀의 위치를 고정하여 쌓이게 설정
        setTimeout(() => {
            pixel91.style.animation = 'none';  // 애니메이션을 중지시킴
            pixel91.style.bottom = `${stackHeights91[leftPosition91]}px`;  // 쌓여야 할 위치에 픽셀을 배치
            stackHeights91[leftPosition91] += 15;  // 다음 픽셀이 쌓일 높이를 증가시킴
            if (stackHeights91[leftPosition91] > 61) {
                pixelContainer91.removeChild(pixel91)
            } else if (leftPosition91 > 3) {
                pixelContainer91.removeChild(pixel91)
            }

        }, duration91 * 1000);
    }
}
// 일정 간격으로 새로운 픽셀을 생성
setInterval(createPixel91, 3);  // 간격을 줄여서 픽셀 생성 속도를 높임

